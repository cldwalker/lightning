require 'yaml'
module Lightning
  # Handles reading and writing of a config file used to generate bolts and commands and offer
  # custom Lightning behavior.
  class Config < ::Hash
    class <<self
      attr_accessor :config_file
      # Defaults to a local lightning.yml if it exists. Otherwise a global ~/.lightning.yml.
      def config_file
        @config_file ||= File.exists?('lightning.yml') ? 'lightning.yml' :
          File.join(Lightning.home,".lightning.yml")
      end

      def bolt(globs)
        {'globs'=>globs.map {|e| e.sub(/^~/, Lightning.home) }}
      end
    end

    DEFAULT = {:complete_regex=>true, :bolts=>{}, :shell_commands=>{'cd'=>'cd', 'echo'=>'echo'} }
    def initialize(hash=read_config_file)
      hash = DEFAULT.merge hash
      super
      replace(hash)
    end

    def source_file
      @source_file ||= self[:source_file] || File.join(Lightning.dir, 'functions.sh')
    end

    # Global shell commands used to generate Functions for all Bolts.
    # @return [Array]
    def global_commands
      shell_commands.keys
    end

    # @return [Hash]
    # Maps shell command names to their aliases using @config[:shell_commands]
    def shell_commands
      self[:shell_commands]
    end

    def unaliased_command(cmd)
      shell_commands.invert[cmd] || cmd
    end

    def create_shell_command(scmd, scmd_alias=nil)
      scmd_alias ||= scmd
      if shell_commands.values.include?(scmd_alias)
        puts "Alias '#{scmd_alias}' already exists for shell command '#{unaliased_command(scmd_alias)}'"
      else
        shell_commands[scmd] = scmd_alias
        save_and_say "Added shell command '#{scmd}'"
      end
    end

    def delete_shell_command(scmd)
      if shell_commands[scmd]
        shell_commands.delete scmd
        save_and_say "Deleted shell command '#{scmd}' and its functions"
      else
        puts "Can't find shell command '#{scmd}'"
      end
    end

    def bolts
      self[:bolts]
    end

    def create_function_and_bolt(argv)
      bolt = unalias_bolt(argv[1])
      (bolts[bolt] || Generator.run(bolt, :once=>bolt)) &&
        create_function(argv[0], bolt, :name=>argv[2])
    end

    def create_function(scmd, bolt, options={})
      options[:name] ||= function_name(scmd, Lightning.bolts[bolt].alias_or_name) unless global_commands.include?(scmd)
      function = options[:name] || function_name(scmd, Lightning.bolts[bolt].alias_or_name)

      if find_function(bolts[bolt]['functions'], 'shell_command', scmd)
        puts("Function '#{function}' already exists")
      else
        if_bolt_found(bolt) do |bolt|
          fn = options[:name] ? {'name'=>options[:name],'shell_command'=>scmd} : scmd
          (bolts[bolt]['functions'] ||= []) << fn
          save_and_say "Created function '#{function}'"
        end
      end
    end

    # Extracts shell command from a shell_command string
    def only_command(shell_command)
      shell_command[/\w+/]
    end

    # Creates a command name from its shell command and bolt i.e. "#{command}-#{bolt}".
    # Uses aliases for either if they exist.
    def function_name(shell_command, bolt)
      cmd = only_command shell_command
      "#{shell_commands[cmd] || cmd}-#{bolt}"
    end

    def find_function(functions, attribute, query)
      Array(functions).find {|e|
        attribute != 'shell_command' ? (e.is_a?(Hash) && e[attribute] == query) :
          only_command(e.is_a?(Hash) ? e['shell_command'] : e) == query
      }
    end

    def delete_function(fn)
      if (function = Lightning.functions[fn])
        cmd = unaliased_command(fn.split('-')[0])
        if_bolt_found(function.bolt.name) {|bolt|
          if (element = find_function(bolts[bolt]['functions'], 'name', fn) ||
              find_function(bolts[bolt]['functions'], 'shell_command', cmd) )
            bolts[bolt]['functions'].delete(element)
            return save_and_say("Deleted function '#{fn}'")
          elsif function.bolt.global && global_commands.include?(cmd)
            return puts("Can't delete function '#{fn}' which is generated by a shell command '#{cmd}'.",
            "Can only delete by deleting shell command: shell_command delete #{cmd}")
          end
        }
      end
      puts "Can't find function '#{fn}'"
    end

    def create_bolt(bolt, globs)
      bolts[bolt] = self.class.bolt(globs)
      save_and_say "Created bolt '#{bolt}'"
    end

    def unalias_bolt(bolt)
      bolts[bolt] ? bolt : (Array(bolts.find {|k,v| v['alias'] == bolt })[0] || bolt)
    end

    def if_bolt_found(bolt)
      bolt = unalias_bolt(bolt)
      bolts[bolt] ? yield(bolt) : puts("Can't find bolt '#{bolt}'")
    end

    def alias_bolt(bolt, bolt_alias)
      if_bolt_found(bolt) do |bolt|
        bolts[bolt]['alias'] = bolt_alias
        save_and_say "Aliased bolt '#{bolt}' to '#{bolt_alias}'"
      end
    end

    def delete_bolt(bolt)
      if_bolt_found(bolt) do |bolt|
        bolts.delete(bolt)
        save_and_say "Deleted bolt '#{bolt}' and its functions"
      end
    end

    def show_bolt(bolt)
      if_bolt_found(bolt) {|b| puts bolts[b].to_yaml.sub("--- \n", '') }
    end

    def globalize_bolts(boolean, arr)
      return puts("First argument must be 'on' or 'off'") unless %w{on off}.include?(boolean)
      if boolean == 'on'
        valid = arr.select {|b| if_bolt_found(b) {|bolt| bolts[bolt]['global'] = true } }
        save_and_say "Global on for bolts #{valid.join(', ')}"
      else
        valid = arr.select {|b| if_bolt_found(b) {|bolt| bolts[bolt].delete('global') ; true } }
        save_and_say "Global off for bolts #{valid.join(', ')}"
      end
    end

    # Saves config to Config.config_file
    def save
      File.open(self.class.config_file, "w") {|f| f.puts Hash.new.replace(self).to_yaml }
    end

    protected
    def save_and_say(message)
      save
      puts message
    end

    def read_config_file
      File.exists?(self.class.config_file) ?
        Util.symbolize_keys(YAML::load_file(self.class.config_file)) : {}
    rescue
      raise $!.message.sub('syntax error', "Syntax error in '#{Config.config_file}'")
    end
  end
end
